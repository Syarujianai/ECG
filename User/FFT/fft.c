#include <math.h>	
#include "fft.h"				
/**************************宏********************************/

#define N 64      //64点
#define log2N 6   //log2N=6

double Mag[80];//输出模值
double Mag_total;
complex Ecg_FFT[256]={0};//输入序列

/*复数加法*/
complex add(complex a, complex b)

{

	complex c;

	c.real = a.real + b.real;

	c.img = a.img + b.img;

	return c;

}

/*复数减法*/

complex sub(complex a, complex b)

{

	complex c;

	c.real = a.real - b.real;

	c.img = a.img - b.img;

	return c;

}

/*复数乘法*/

complex mul(complex a, complex b)

{

	complex c;

	c.real = a.real*b.real - a.img*b.img;

	c.img = a.real*b.img + a.img*b.real;

	return c;

}



/***码位倒序函数***/

static void Reverse()

{

	unsigned int i, j, k;

	unsigned int t;

	complex temp;//临时交换变量

	for (i = 0; i<N; i++)//从第0个序号到第N-1个序号

	{

		k = i;//当前第i个序号

		j = 0;//存储倒序后的序号，先初始化为0

		for (t = 0; t<log2N; t++)//共移位t次，其中log2N是事先宏定义算好的

		{

			j <<= 1;

			j |= (k & 1);//j左移一位然后加上k的最低位

			k >>= 1;//k右移一位，次低位变为最低位

		}

		if (j>i)//如果倒序后大于原序数，就将两个存储单元进行交换（判断j>i是为了防止重复交换）

		{

			temp = Ecg_FFT[i];

			Ecg_FFT[i] = Ecg_FFT[j];

			Ecg_FFT[j] = temp;

		}

	}

}

complex WN[N] =//旋转因子数组
{ //为节省CPU计算时间，旋转因子采用查表处理
  //★根据实际FFT的点数N，该表数据需自行修改
  //以下结果通过Excel自动生成
  //  WN[k].real=cos(2*PI/N*k);
  //  WN[k].img=-sin(2*PI/N*k);

	{ 1.00000,0.00000 },{ 0.99518,-0.09802 },{ 0.98079,-0.19509 },{ 0.95694,-0.29028 },
	{ 0.92388,-0.38268 },{ 0.88192,-0.47140 },{ 0.83147,-0.55557 },{ 0.77301,-0.63439 },
	{ 0.70711,-0.70711 },{ 0.63439,-0.77301 },{ 0.55557,-0.83147 },{ 0.47140,-0.88192 },
	{ 0.38268,-0.92388 },{ 0.29028,-0.95694 },{ 0.19509,-0.98079 },{ 0.09802,-0.99518 },
	{ 0.00000,-1.00000 },{ -0.09802,-0.99518 },{ -0.19509,-0.98079 },{ -0.29028,-0.95694 },
	{ -0.38268,-0.92388 },{ -0.47140,-0.88192 },{ -0.55557,-0.83147 },{ -0.63439,-0.77301 },
	{ -0.70711,-0.70711 },{ -0.77301,-0.63439 },{ -0.83147,-0.55557 },{ -0.88192,-0.47140 },
	{ -0.92388,-0.38268 },{ -0.95694,-0.29028 },{ -0.98079,-0.19509 },{ -0.99518,-0.09802 },
	{ -1.00000,0.00000 },{ -0.99518,0.09802 },{ -0.98079,0.19509 },{ -0.95694,0.29028 },
	{ -0.92388,0.38268 },{ -0.88192,0.47140 },{ -0.83147,0.55557 },{ -0.77301,0.63439 },
	{ -0.70711,0.70711 },{ -0.63439,0.77301 },{ -0.55557,0.83147 },{ -0.47140,0.88192 },
	{ -0.38268,0.92388 },{ -0.29028,0.95694 },{ -0.19509,0.98079 },{ -0.09802,0.99518 },
	{ 0.00000,1.00000 },{ 0.09802,0.99518 },{ 0.19509,0.98079 },{ 0.29028,0.95694 },
	{ 0.38268,0.92388 },{ 0.47140,0.88192 },{ 0.55557,0.83147 },{ 0.63439,0.77301 },
	{ 0.70711,0.70711 },{ 0.77301,0.63439 },{ 0.83147,0.55557 },{ 0.88192,0.47140 },
	{ 0.92388,0.38268 },{ 0.95694,0.29028 },{ 0.98079,0.19509 },{ 0.99518,0.09802 }
};

void FFT(u16 *BUF)

{	
	unsigned int i, j, k, l;

	complex top, bottom, xW;
	
	for(i=0;i<256;i++)
	{
		Ecg_FFT->real=(float)BUF[i]/4096*3.3-1.23;	
	}

	Reverse(); //码位倒序

	for (i = 0; i<log2N; i++)   /*共log2N级*/

	{    //一级蝶形运算

		l = 1 << i;//l等于2的i次方

		for (j = 0; j<N; j += 2 * l)  /*每L个蝶形是一组，每级有N/2L组*/

		{   //一组蝶形运算

			for (k = 0; k<l; k++)   /*每组有L个*/

			{  //一个蝶形运算

				xW = mul(Ecg_FFT[j + k + l], WN[N / (2 * l)*k]); //碟间距为l

				top = add(Ecg_FFT[j + k], xW); //每组的第k个蝶形

				bottom = sub(Ecg_FFT[j + k], xW);

				Ecg_FFT[j + k] = top;

				Ecg_FFT[j + k + l] = bottom;

			}

		}
		
	}
	Mag_total=0;
	
  for(i=0;i<80;i++) 		 
	{
		Mag[i]=sqrt(Ecg_FFT[i].img*Ecg_FFT[i].img+Ecg_FFT[i].real*Ecg_FFT[i].real);
		
		Mag_total+=Mag[i];
		
	}
	
}

